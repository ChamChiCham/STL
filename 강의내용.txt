== 3/5 1.1 ==
기존 c++
- class : function / variable
- 자료 생성 방법 1. STACK 2.DATA 3. Free Store
- generic -> template 


기존 c++
특정 자료형에 집중


STL
특정 자료형과 무관
자료구조 + 알고리즘
* 자료의 갯수가 많다

== 3/7 1.2 ==
c++ PL(Paradigm)
- object oriented: 특정 자료형에 중점(특정 자료형을 어떻게 만들것인지?)

- Generic: 특정 자료형과 무관한 코딩
 -> template

 함수 -> 알고리즘
 클래스 -> data structure

* 접점: 비슷한 클래스가 많을 때 이를 Generic으로 처리 가능한가?

== 3/12 2.1 ==

Low <---------------------------> High
STACK /     Free store     / DATA / CODE

CODE영역에서의 change(int&, int&)와 change(Dog&, Dog&)는 다르다.
왜 함수 오버로딩이 가능한가?
 -> 컴파일러가 name mangling을 하기 때문.

- array
int a[100];

중요! contiguous memory: 공간의 연속 메모리
+ continuous: 시간의 연속

장점: 특정 메모리를 access하는데 O(1)의 시간이 걸린다.
+ cash hit


== 3/14 2.2 ==

array<int, 100>

이 메모리를 문자 말고 그대로 저장할 순 없을까?

-> 저수준 출력
함수(어디에?, 뭘?)
(out, a.data(), 400)(가장 효율적인 코드) -> cpu가 개입하지 않는 명령어 -> DMA

File I/O

Open mode:
1. text mode 로 열게 되면 (0x0A -> 0x0A0D)	->	high(가공)
2. binary mode 변형 없이 그대로			-\>	low(read, write)


== 3/19 3.1 ==

메모리에 있는 주소를 가져오는 방법

1. dogs.data()
2. &dogs[0]
3. &dogs

여기서 1번의 방법을 고수하는게 좋음.

begin(), end()


[begin()| | | | | | ][end()]
왜 end()가 마지막 원소 + 1인가?
1. e-b = 800 -> 처리할 개수를 알 수 있음.



=== 3/21 3.2 ===

빌드해서 컴파일 할 경우 *.exe 파일이 하드디스크에 생성된다.

.exe --VS-->
메모리에 정보를 저장하는 순서
1. DATA
2. CODE
3. STACK
4. Free Store
[3. STACK (int num) |  매우매우큼   | 1.DATA | 2.CODE main{ int num}, f, save ]
		   		                   -> 3. STACK에 메모리 생성
						   int* p = new int;
						   -> 3. p 메모리 생성
						   -> 4. FS 중간 메모리 생성 
이때 함수의 이름은 시작번지
따라서 정식 호출방법은 (*f)();

[ STACK |  Free Store(HEAP)  | DATA | CODE ] 
Low   <->   High
	main 메모리
이론적으론 x64에서 더 큰 메모리를 사용할 수 있으나 몇십기가로 제한되어 있다.

== 3/26 4.1 ===
1. compile time -> T[N] -> constexpr
2. run time -> new T[N]
		-> 이런 코드는 가능하면 X 왜? 느려짐.

[ STACK |  Free Store(HEAP)  | CODE | DATA(2GB) ] 
int* data{ new int[num]{} };
Free Store에 num사이즈 정보가 생기면 주소를 반환. 이를 STACK에 저장되어 있는 int* data가 저장

######################
*** 시험문제 출제 예상 (의견 제출식으로) 한번 생각해보기.
#######################
new int[3'000'000'000]; -> 12GB contigous -> 메모리 확보 실패
-> 왜???

new int[10'000'000'000]; -> 40GB contigous -> 메모리 확보 실패

smart pointer:
c++ 언어에서 메모리 관리 보장 -> stack-unwinding
-> RAII

== 3/28 4.2 ===

unique_ptr<Dog>

stack-unwinding
메모리 관리 보장 -> 소멸자를 자동으로 호출한다.

== 4/2 5.1 ===

